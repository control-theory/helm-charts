apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-config
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "aigent.labels" . | nindent 4 }}
data:
  aigent.yaml: |
    # === OpenTelemetry Receivers ===
    receivers:
      otlp:
        protocols:
          grpc:
            endpoint: 0.0.0.0:{{ .Values.ports.otelgrpc }}
          http:
            endpoint: 0.0.0.0:{{ .Values.ports.otelhttp }}
            cors:
              allowed_origins: ["*"]
              allowed_headers: ["*"]
{{- if .Values.gateway.enabled }}
      k8sobjects:
        objects:
          - name: events
            mode: watch
            group: events.k8s.io
{{- if .Values.gateway.includeNamespaces }}
            namespaces:
{{- range .Values.gateway.includeNamespaces }}
              - {{ . }}
{{- end }}
{{- end }}
            exclude_watch_type:
              - DELETED
{{- end }}

    processors:
      # Batch processor for logs - reduces number of export calls and memory pressure
      batch:
        send_batch_size: 1000
        timeout: 1s
        send_batch_max_size: 2000

      # Add deployment environment and cluster name as resource attributes
      resource:
        attributes:
          - key: deployment.environment
            value: {{ .Values.environment }}
            action: upsert
          - key: k8s.cluster.name
            value: {{ .Values.cluster }}
            action: upsert

      # Transform k8s events to add severity information and format body
      transform/k8sobjects:
        error_mode: ignore
        log_statements:
          - context: log
            statements:
              # Capture context from Event "regarding" section (in body["object"])
              - set(attributes["k8s.regarding.kind"], body["object"]["regarding"]["kind"])
              - set(attributes["k8s.regarding.name"], body["object"]["regarding"]["name"])
              - set(attributes["k8s.regarding.namespace"], body["object"]["regarding"]["namespace"])

              # Promote to resource attributes if available
              - set(resource.attributes["k8s.namespace.name"], body["object"]["regarding"]["namespace"]) where body["object"]["regarding"]["namespace"] != nil
              - set(resource.attributes["k8s.pod.name"], body["object"]["regarding"]["name"]) where body["object"]["regarding"]["kind"] == "Pod"
              - set(resource.attributes["k8s.node.name"], body["object"]["regarding"]["name"]) where body["object"]["regarding"]["kind"] == "Node"
              - set(resource.attributes["k8s.deployment.name"], body["object"]["regarding"]["name"]) where body["object"]["regarding"]["kind"] == "Deployment"
              - set(resource.attributes["k8s.job.name"], body["object"]["regarding"]["name"]) where body["object"]["regarding"]["kind"] == "Job"
              - set(resource.attributes["k8s.cronjob.name"], body["object"]["regarding"]["name"]) where body["object"]["regarding"]["kind"] == "CronJob"

              # Optionally derive workload name if it's a ReplicaSet event
              # Note: ReplicaSet names are formatted as <deployment-name>-<hash>
              # First copy the name, then strip the hash suffix using replace_pattern
              - set(resource.attributes["k8s.deployment.name"], body["object"]["regarding"]["name"]) where body["object"]["regarding"]["kind"] == "ReplicaSet"
              - replace_pattern(resource.attributes["k8s.deployment.name"], "-[^-]+$$", "") where body["object"]["regarding"]["kind"] == "ReplicaSet"

              # Additional event metadata attributes
              - set(attributes["k8s.event.type"], body["object"]["type"])
              - set(attributes["k8s.event.reason"], body["object"]["reason"])
              - set(attributes["k8s.event.count"], body["object"]["deprecatedCount"])
              - set(attributes["k8s.event.action"], body["object"]["action"])
              - set(attributes["k8s.event.reportingComponent"], body["object"]["reportingController"])

              # Severity based on event type
              - set(severity_text, "WARNING") where body["object"]["type"] == "Warning"
              - set(severity_number, 13) where body["object"]["type"] == "Warning"
              - set(severity_text, "INFO") where body["object"]["type"] != "Warning"
              - set(severity_number, 9) where body["object"]["type"] != "Warning"

              # Model-readable message: reason, note.
              - set(body, Concat([
                  body["object"]["reason"], " - ", body["object"]["note"]], ""))

      # Derive service.name from k8s resource attributes with intelligent fallback
      transform/derive-service-name:
        error_mode: ignore
        log_statements:
          - context: resource
            statements:
              # Skip if service.name already exists
              - set(resource.attributes["service.name"],
                    resource.attributes["k8s.deployment.name"])
                where resource.attributes["service.name"] == nil and resource.attributes["k8s.deployment.name"] != nil

              - set(resource.attributes["service.name"],
                    resource.attributes["k8s.cronjob.name"])
                where resource.attributes["service.name"] == nil and resource.attributes["k8s.cronjob.name"] != nil

              - set(resource.attributes["service.name"],
                    resource.attributes["k8s.job.name"])
                where resource.attributes["service.name"] == nil and resource.attributes["k8s.job.name"] != nil

              - set(resource.attributes["service.name"],
                    resource.attributes["k8s.statefulset.name"])
                where resource.attributes["service.name"] == nil and resource.attributes["k8s.statefulset.name"] != nil

              - set(resource.attributes["service.name"],
                    resource.attributes["k8s.daemonset.name"])
                where resource.attributes["service.name"] == nil and resource.attributes["k8s.daemonset.name"] != nil

              # If we only have a Pod name, derive service.name by stripping hash suffix
              # Note: Pod names are typically formatted as <deployment>-<replicaset-hash>-<pod-hash>
              # Copy the pod name first, then strip the last two dash-separated segments
              - set(resource.attributes["service.name"], resource.attributes["k8s.pod.name"])
                where resource.attributes["service.name"] == nil and resource.attributes["k8s.pod.name"] != nil
              - replace_pattern(resource.attributes["service.name"], "-[^-]+-[^-]+$$", "")
                where resource.attributes["service.name"] != nil and resource.attributes["k8s.pod.name"] != nil

              # If that fails (empty after replacement), fall back to the full pod name
              - set(resource.attributes["service.name"], resource.attributes["k8s.pod.name"])
                where resource.attributes["service.name"] == "" and resource.attributes["k8s.pod.name"] != nil

              # For k8s events about nodes, use a special naming convention
              - set(resource.attributes["service.name"],
                    Concat(["k8s-node-", resource.attributes["k8s.node.name"]], ""))
                where resource.attributes["service.name"] == nil
                  and resource.attributes["k8s.node.name"] != nil
                  and attributes["k8s.regarding.kind"] == "Node"

              # For k8s events, use the regarding object name
              - set(resource.attributes["service.name"], attributes["k8s.regarding.name"])
                where resource.attributes["service.name"] == nil and attributes["k8s.regarding.name"] != nil

              # Absolute last resort: use container name
              - set(resource.attributes["service.name"], resource.attributes["k8s.container.name"])
                where resource.attributes["service.name"] == nil and resource.attributes["k8s.container.name"] != nil

      # Kubernetes attributes processor
      k8sattributes:
        passthrough: false
        extract:
          metadata:
            - k8s.namespace.name
            - k8s.deployment.name
            - k8s.pod.name
            - k8s.pod.uid
            - k8s.node.name
          labels:
            - tag_name: app
              key: app
              from: pod
        pod_association:
          - sources:
              - from: resource_attribute
                name: k8s.pod.ip
          - sources:
              - from: resource_attribute
                name: k8s.pod.uid
          - sources:
              - from: connection

      # Resource detection processor
      # override: false ensures we don't overwrite attributes from upstream collectors
      resourcedetection:
        detectors: [env, system]
        timeout: 5s
        override: false

    exporters:
      debug:
      debug/k8sobjects:
        verbosity: detailed
      nop:

    connectors:
      connectorbob/logs:
        statler_extension: statler

    extensions:
      statler:
        start_server: false
        start_client: true
        {{- $bobo := .Values.boboAPI | default dict -}}
        {{- if and $bobo $bobo.enable }}
        bobo_api:
          enabled: true
          provider: {{ $bobo.provider | default "openai" | quote }}
          {{- $openai := $bobo.openai | default dict }}
          openai:
            api_key: {{ required "boboAPI.openai.apiKey is required (LiteLLM API key)" $openai.apiKey | quote }}
            model: {{ $openai.model | default "gpt-5-nano" | quote }}
            base_url: {{ required "boboAPI.openai.baseURL is required (e.g., http://litellm.litellm.svc.cluster.local:4000/v1)" $openai.baseURL | quote }}
            temperature: {{ $openai.temperature | default 0.3 }}
            max_tokens: {{ $openai.maxTokens | default 0 }}
            max_log_samples: {{ $openai.maxLogSamples | default 100 }}
        {{- end }}
        client:
          export_interval: 60s
          bucket_size: 60s
          max_log_samples: 1000
          max_patterns: 7
          group_by_dimensions: ["service", "deployment", "pod", "category", "phrase", "host"]
          {{- if .Values.useChdbAccumulator }}
          use_chdb_accumulator: true
          {{- end }}
          {{- if .Values.useDuckDBAccumulator }}
          use_duckdb_accumulator: true
          {{- end }}
          server_address: {{ required "butler.endpoint is required (e.g., butler.namespace.stage.controltheory.com:443)" .Values.butler.endpoint }}
          use_tls: {{ .Values.butler.useTLS }}

    service:
      telemetry:
        logs:
          level: "INFO"
          encoding: "json"
        metrics:
          level: "none"
      extensions:
        - statler
      pipelines:
{{- if .Values.gateway.enabled }}
        # Gateway mode: Full processing pipeline for application logs
        logs:
          receivers:
            - otlp
          processors:
            - k8sattributes
            - transform/derive-service-name  # Derive service.name from k8s resource attributes
            - resourcedetection
            - resource
            - batch                          # Batch logs before connectorbob to reduce ConsumeLogs calls
          exporters:
            - connectorbob/logs

        # Kubernetes events pipeline with detailed logging
        logs/k8sobjects:
          receivers:
            - k8sobjects
          processors:
            - transform/k8sobjects           # Extract k8s event fields and format body
            - k8sattributes                  # Enrich with k8s metadata
            - transform/derive-service-name  # Derive service.name from k8s resource attributes
            - resourcedetection
            - resource
            - batch                          # Batch logs before connectorbob to reduce ConsumeLogs calls
          exporters:
            - connectorbob/logs
            - debug/k8sobjects

        # ConnectorBob output pipeline (Statler summaries)
        logs/connectorbob:
          receivers:
            - connectorbob/logs
          exporters:
            - nop

        # Traces pipeline with full processing
        traces:
          receivers:
            - otlp
          processors:
            - k8sattributes
            - resourcedetection
            - resource
          exporters:
            - nop

        # Metrics pipeline with full processing
        metrics:
          receivers:
            - otlp
          processors:
            - k8sattributes
            - resourcedetection
            - resource
          exporters:
            - nop
{{- else }}
        # Standard mode: Minimal processing for pre-processed data
        logs:
          receivers:
            - otlp
          processors:
            - resource
            - batch                          # Batch logs before connectorbob to reduce ConsumeLogs calls
          exporters:
            - connectorbob/logs

        # ConnectorBob output pipeline (Statler summaries)
        logs/connectorbob:
          receivers:
            - connectorbob/logs
          exporters:
            - nop

        # Traces pipeline with basic processing
        traces:
          receivers:
            - otlp
          processors:
            - resource
          exporters:
            - nop

        # Metrics pipeline with basic processing
        metrics:
          receivers:
            - otlp
          processors:
            - resource
          exporters:
            - nop
{{- end }}
